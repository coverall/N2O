<?php

/*
 * N2O error definitions and application error handling function
 */
  
// tell PHP that N2O will do its own error handling
error_reporting((isset($showErrorsOfType) ? $showErrorsOfType : E_ALL ^ E_NOTICE));

// point PHP to the following error handler
set_error_handler('applicationErrorHandler');	

define('EM_APPLICATION_ERROR', 'application');
define('EM_FIELD_ERROR', 'field');
define('EM_USER_ERROR', 'user');

/*
 * applicationErrorHandler is the global N2O error handling function that is automatically called when trigger_error is evoked and is automatically passed its parameters. trigger_error takes two parameters, the first is the errormessage string and the second, optional parameter is the errorNumber which is a value from the list in CC_ErrorManager.
 * @see CC_ErrorManager
 */

function applicationErrorHandler($errno, $errmsg, $filename, $linenum, $vars)
{
	global $logUserErrors;
	global $logApplicationErrors;
	global $application;
	
	// define an assoc array of error string	
	// in reality the only entries we should
	// consider are 2,8,256,512 and 1024
	$errortype = array (
		1   =>  'Error',
		2   =>  'Warning',
		4   =>  'Parsing Error',
		8   =>  'Notice',
		16  =>  'Core Error',
		32  =>  'Core Warning',
		64  =>  'Compile Error',
		128 =>  'Compile Warning',
		256 =>  'User Error',
		512 =>  'User Warning',
		1024=>  'User Notice'
	);
		
	$verboseError = $errortype[$errno] . '(' . $errno . ') ' . $errmsg . ' in ' . $filename . ' at line: ' . $linenum;
	
	if ($logUserErrors)
	{
		// write to the virtualhost error log
		error_log('[' . $_SERVER['REMOTE_ADDR'] . '] ' . $verboseError, 0);
	}	

	switch ($errno)
	{
		// a non-fatal notice, displayed, generated by trigger_error()
		// (EM_USER_ERROR error in N2O) 
		case E_USER_NOTICE:
		{
			if (is_object($application))
			{
				$application->errorManager->addUserError($errno, $errmsg, $verboseError);
			}
		}
		break;
		
		// a fatal error, not displayed, generated by using trigger_error()
		// (EM_APPLICATION_ERROR error in N2O) 
		case E_ERROR:
		// this handles fatal PHP-generated errors 
		// (EM_APPLICATION_ERROR error in N2O)
		case E_CORE_ERROR:
		case E_USER_ERROR:
		{
			if (is_object($application))
			{
				$application->errorManager->addApplicationError($errno, $errmsg, $verboseError, true);
			}
		}
		break;

		// a non-fatal error, not displayed, generated by using trigger_error() 
		// (EM_APPLICATION_ERROR error in N2O)
		case E_USER_WARNING:
		// this handles the balance of non-fatal PHP-generated errors 
		// (EM_APPLICATION_ERROR error in N2O)
		default:
		{
			if (is_object($application))
			{
				$application->errorManager->addApplicationError($errno, $errmsg, $verboseError, false);
			}
		}
		break;
	}
}


//=======================================================================
// CLASS: CC_ErrorManager
//=======================================================================

/**
 * 
 * The PHP (and N2O) defined application error types and their values:
 * -------------------------------------------------------------------
 * 
 * 1 E_ERROR (Fatal run-time errors. These indicate errors that can not be recovered from, such as a memory allocation problem. Execution of the script is halted.)
 * 2 E_WARNING (Run-time warnings (non-fatal errors). Execution of the script is not halted.)
 * 4 E_PARSE (Compile-time parse errors. Parse errors should only be generated by the parser.)
 * 8 E_NOTICE (Run-time notices. Indicate that the script encountered something that could indicate an error, but could also happen in the normal course of running a script.)
 * 16 E_CORE_ERROR (Fatal errors that occur during PHP's initial startup. This is like an E_ERROR, except it is generated by the core of PHP.)
 * 32 E_CORE_WARNING (Warnings (non-fatal errors) that occur during PHP's initial startup.       This is like an E_WARNING , except it is generated by the core of PHP.)
 * 64 E_COMPILE_ERROR (Fatal compile-time errors. This is like an E_ERROR, except it is generated by the Zend Scripting Engine.) 
 * 128 E_COMPILE_WARNING (Compile-time warnings (non-fatal errors). This is like an E_WARNING, except it is generated by the Zend Scripting Engine.)
 * 256 E_USER_ERROR (User-generated error message. This is like an E_ERROR, except it is generated in PHP code by using the PHP function trigger_error().)
 * 512 E_USER_WARNING (User-generated warning message. This is like an E_WARNING, except it is generated in PHP code by using the PHP function trigger_error().)
 * 1024 E_USER_NOTICE (User-generated notice message. This is like an E_NOTICE, except it is generated in PHP code by using the PHP function trigger_error().)
PHP 4 only
 *
 * @package CC_Managers
 * @access public
 * @author The Crew <N2O@coverallcrew.com>
 * @copyright Copyright &copy; 2003, Coverall Crew
 * @see CC_Error
 */
 
class CC_ErrorManager
{

	/**
     * A two dimensional array for errors where the first element is the error type (defined in the _init method) and the second in an array of CC_Error objects.
     *
     * @var array $_errors
     * @access private
     * @see init()
     */

	var $_errors = array();
	

	//-------------------------------------------------------------------
	// CONSTRUCTOR: CC_ErrorManager
	//-------------------------------------------------------------------
	
	/**
	 * The constructor where buffer sizes are hard-coded. The init method is called here to initialize the error arrays of different types.
	 * 
	 * @access private
	 * @see init()
	 */
	 
	function CC_ErrorManager()
	{		
		//------------------------------------------------------------------
		//newly added error types should implement the following sample code
		
		// X. <NEW TYPE> ERRORS
		// (<description>) 
				
		//$this-><newType>BufferSize = $<newType>ErrorBufferSize;
		//
		// Don't forget to :
		//		1) make them member variables and add them to the CC_ErrorManager 
		//		init() method 
		//------------------------------------------------------------------
				
		$this->_init();
	}
	
	
	//-------------------------------------------------------------------
	// METHOD: _init()
	//-------------------------------------------------------------------
	
	/**
	 * This method clears/initializes all error arrays. Any new error types must be added here in the same way as the others for initialization.
	 *
	 * @access private
	 */
	 
	function _init()
	{
		//---------------------------------------------------------
		// Error types and codes with their respective buffer sizes
		//---------------------------------------------------------

		// 0. APPLICATION ERRORS
		// (errors caused as result of application errors) 
		$this->_errors[EM_APPLICATION_ERROR] = array();

		// 1. FIELD ERRORS
		// (errors caused as result of invalid fields or missing data) 
		$this->_errors[EM_FIELD_ERROR] = array();

		// 2. USER ERRORS
		// (errors caused as result of user errors from application logic) 
		$this->_errors[EM_USER_ERROR] = array();
	}
	
		
	//-------------------------------------------------------------------
	// METHOD: _addError()
	//-------------------------------------------------------------------

	/**
	 * This method adds errors of any type to CC_Error_Manager's _errors array. 
	 *
	 * @access private
	 * @param string $type the error type to add  (eg. EM_USER_ERROR, EM_FIELD_ERROR, EM_APPLICATION_ERROR).
	 * @param int $code the error code which should be defined in CC_Error or the CC_Application subclass.
	 * @param string $userMessage a simple error message for the user 
	 * @param string $verboseMessage a more verbose error message for debugging 
	 * @param bool $fatal presently unused 
	 * @param bool $display presently unused 
	 */
	 
	function _addError($type, $code, $userMessage, $verboseMessage, $fatal = false, $display = true)
	{
		$application = &getApplication();
		
		$errorArray = &$this->_errors[$type];
		
		if (is_array($errorArray))
		{		
			if (sizeof($errorArray) < $this->getBufferSize($type))
			{
				$errorArray[] = new CC_Error($code, $userMessage, $verboseMessage, $fatal, $display);
			}
			else
			{
				// cycle around by removing the first element and adding to the last
				
				$size = sizeof($this->errorArray) - 1;
				
				for ($i = 1; $i < $size; $i++)
				{
					$errorArray[$i - 1] = $errorArray[$i]; 
				}

				unset($size);

				$errorArray[$i] = new CC_Error($code, $userMessage, $verboseMessage, $fatal, $display);
			}
		}
		else
		{
			$applicationErrorArray = &$this->_errors[EM_APPLICATION_ERROR][0];
			
			if (is_array($applicationErrorArray))
			{
				trigger_error("The '$type' error array did not exist.");
			}
			else
			{
				trigger_error("CC_ErrorManager()->addError($type): The EM_APPLICATION_ERROR error array did not exist.", E_USER_WARNING);
			}
		}
		
		if ($fatal == true)
		{
			$application->cc_die($verboseMessage);
		}
	}
	
	
	//-------------------------------------------------------------------
	// METHOD: addUserError()
	//-------------------------------------------------------------------
	
    /**
	 * This method adds 'user' errors to CC_Error_Manager. 'user' errors are those caused by end-user actions and are non-fatal but may necessitate displaying an error message.
	 *
	 * @access private
	 * @param int $code the error code which should be defined in CC_Error or the CC_Application subclass.
	 * @param string $errorMessage a descriptive error message 
	 * @param bool $display whether or not this error message should be displayed on the screen
	 */

	function addUserError($code, $errorMessage, $display)
	{
		$this->_addError(EM_USER_ERROR, $code, $errorMessage, $errorMessage, false, $display);
	}
	
	
	//-------------------------------------------------------------------
	// METHOD: addFieldError()
	//-------------------------------------------------------------------
	
    /**
	 * This method adds 'field' type errors to CC_Error_Manager. 'field' errors are those errors caused by missing or invalid field submission.
	 *
	 * @access private
	 * @param int $code the error code which should be defined in CC_Error 
	 * or the CC_Application subclass.
	 * @param string $errorMessage a descriptive error message 
	 * @param bool $display whether or not this error message should be displayed on the screen
	 */

	function addFieldError($code, $errorMessage, $display)
	{
		$this->_addError(EM_FIELD_ERROR, $code, $errorMessage, $errorMessage, false, $display);
	}
	
	
	//-------------------------------------------------------------------
	// METHOD: addApplicationError()
	//-------------------------------------------------------------------

	/**
	 * This method adds 'application' type errors to CC_Error_Manager. 'application' errors are those that are the result of application-level errors (ie. are not caused by erroneous user actions or uncontrollable system failures).
	 *
	 * @access private
	 * @param int $code the error code which should be defined in CC_Error or the CC_Application subclass.
	 * @param string $errorMessage a simple error message
	 * @param string $verboseErrorMessage a more verbose error message for debugging 
	 * @param bool $fatal Whether or not this error necessitates haltin execution of the application
	 */
	 
	function addApplicationError($code, $errorMessage, $verboseErrorMessage, $fatal)
	{
		$this->_addError(EM_APPLICATION_ERROR, $code, $message, $verboseMessage, $fatal, true);
	}
	
	
	//-------------------------------------------------------------------
	// METHOD: _clearErrorsOfType()
	//-------------------------------------------------------------------
	
	/**
	 * This method clears errors of a given type in CC_Error_Manager's _errors array. 
	 *
	 * @access private
	 * @param string $type the error type to add.
	 */
	 
	function _clearErrorsOfType($type)
	{
		if (is_array($this->_errors[$type]))
		{	
			$this->_errors[$type] = array();
		}
		else
		{
			trigger_error("CC_ErrorManager->clearErrorsOfType($type): The '$type' error array did not exist.", E_USER_WARNING);
		}
	}
	
	
	//-------------------------------------------------------------------
	// METHOD: clearUserErrors()
	//-------------------------------------------------------------------

	/**
	 * This method clears all 'user' errors from CC_ErrorManager.
	 *
	 * @access public
	 */
	 
	function clearUserErrors()
	{
		$this->_clearErrorsOfType(EM_USER_ERROR);
	}
	
	
	//-------------------------------------------------------------------
	// METHOD: clearApplicationErrors()
	//-------------------------------------------------------------------

	/**
	 * This method clears all 'application' errors from CC_ErrorManager.
	 *
	 * @access public
	 */

	function clearApplicationErrors()
	{
		$this->_clearErrorsOfType(EM_APPLICATION_ERROR);
	}
	
	
	//-------------------------------------------------------------------
	// METHOD: clearFieldErrors()
	//-------------------------------------------------------------------
	
	/**
	 * @access public
	 * This method clears all field errors from CC_ErrorManager.
	 */

	function clearFieldErrors()
	{
		$this->_clearErrorsOfType(EM_FIELD_ERROR);
	}
	
	
	//-------------------------------------------------------------------
	// METHOD: _hasErrorsOfType()
	//-------------------------------------------------------------------

	/**
	 * This method informs of the existence of errors of a given type. 
	 *
	 * @access private
	 * @param string $type The type of error to check for.
	 * @return bool Whether or not there is a certain error present.
	 */

	function _hasErrorsOfType($type)
	{
		if (is_array($this->_errors[$type]))
		{
			return (sizeof($this->_errors[$type]) > 0);
		}
		else
		{
			return false;
		}
	}
	
	
	//-------------------------------------------------------------------
	// METHOD: hasUserErrors()
	//-------------------------------------------------------------------
	
	/**
	 * This method informs of the existence of 'user' errors in CC_ErrorManager. 
	 *
	 * @access public
	 * @return bool Whether or not there are 'user' errors present.
	 */
	 
	function hasUserErrors()
	{
		return $this->_hasErrorsOfType(EM_USER_ERROR);
	}
	
	
	//-------------------------------------------------------------------
	// METHOD: hasApplicationErrors()
	//-------------------------------------------------------------------

	/**
	 * This method informs of the existence of 'application' errors in CC_ErrorManager. 
	 *
	 * @access public
	 * @return bool Whether or not there are 'application' errors present.
	 */

	function hasApplicationErrors()
	{
		return $this->_hasErrorsOfType(EM_APPLICATION_ERROR);
	}
	
	
	//-------------------------------------------------------------------
	// METHOD: hasFieldErrors()
	//-------------------------------------------------------------------

	/**
	 * This method informs of the existence of 'field' errors in CC_ErrorManager. 
	 *
	 * @access public
	 * @return bool Whether or not there are 'field' errors present.
	 */

	function hasFieldErrors()
	{
		return $this->_hasErrorsOfType(EM_FIELD_ERROR);
	}
	
	
	//-------------------------------------------------------------------
	// METHOD: clearAllErrors()
	//-------------------------------------------------------------------

	/**
	 * This method clears all CC_ErrorManager errors.  
	 *
	 * @access public
	 * @see init()
	 */

	function clearAllErrors()
	{
		$this->_init();
	}
	
	
	//-------------------------------------------------------------------
	// METHOD: _getErrorsOfType()
	//-------------------------------------------------------------------

	/**
	 * This method retrieves the error array of a given type.
	 *
	 * @access private
	 * @param string $type The type of errors to retrieve.  
	 * @return array Returns an array of CC_Error object of the given type.
	 * @see CC_Error()
	 */

	function _getErrorsOfType($type)
	{
		if (is_array($this->_errors[$type]))
		{
			return $this->_errors[$type];
		}
		else
		{
			trigger_error("The error array of type $type doesn't exist.");
		}
	}


	//-------------------------------------------------------------------
	// METHOD: getUserErrors()
	//-------------------------------------------------------------------

	/**
	 * This method retrieves all the application's 'user' errors.
	 *
	 * @access public
	 * @return array Returns an array of CC_Error objects that are of the 'user' type.
	 * @see CC_Error()
	 */

	function getUserErrors()
	{
		return $this->_getErrorsOfType(EM_USER_ERROR);
	}
	
	
	//-------------------------------------------------------------------
	// METHOD: getFieldErrors()
	//-------------------------------------------------------------------

	/**
	 * This method retrieves all the application's 'field' errors.
	 *
	 * @access public
	 * @return array Returns an array of CC_Error objects that are of the 'field' type.
	 * @see CC_Error()
	 */

	function getFieldErrors()
	{
		return $this->_getErrorsOfType(EM_FIELD_ERROR);
	}
	
	
	//-------------------------------------------------------------------
	// METHOD: getApplicationErrors()
	//-------------------------------------------------------------------

	/**
	 * This method retrieves all the application's 'application' errors.
	 *
	 * @access public
	 * @return array Returns an array of CC_Error objects that are of the 'application' type.
	 * @see CC_Error()
	 */

	function getApplicationErrors()
	{
		return $this->_getErrorsOfType(EM_APPLICATION_ERROR);
	}
	
	
	//-------------------------------------------------------------------
	// METHOD: displayApplicationErrors()
	//-------------------------------------------------------------------

	/**
	 * This method return a string of all the application's 'application' errors.
	 *
	 * @access public
	 * @return string A list of application errors or 'There are no errors.' if there are none. 
	 */

	function displayApplicationErrors()
	{
		if ($this->hasApplicationErrors())
		{
			$applicationErrors = $this->getApplicationErrors();
			$display = 'There are ' . sizeof($applicationErrors) . ' errors!<p>';
			
			for ($i = (sizeof($applicationErrors) - 1); $i >= 0; $i--)
			{
				$applicationError = $applicationErrors[$i]; 
				$display .= $applicationError->getVerboseMessage() . '<br>';
			}
		}
		else
		{
			$display = 'There are no errors.<p>';
		}
		
		return $display;		
	}
	
	
	//-------------------------------------------------------------------
	// METHOD: _popErrorOfType()
	//-------------------------------------------------------------------

	/**
	 * This method gets the last error of a given type and removes it from CC_ErrorManager. 
	 *
	 * @access private
	 * @return CC_Error The CC_Error object of given type.
	 * @see CC_Error
	 */

	function _popErrorOfType($errorType)
	{
		if (is_array($this->_getErrorsOfType($errorType)))
		{			
			return array_pop($this->_getErrorsOfType($errorType));
		}
		else
		{
			trigger_error("Errors of type '$type' were not found!", E_USER_WARNING);
		}		
	}

	
	//-------------------------------------------------------------------
	// METHOD: popUserError()
	//-------------------------------------------------------------------

	/**
	 * This method gets the last 'user' error and removes it from CC_ErrorManager. 
	 *
	 * @access public
	 * @return CC_Error The last 'user' error.
	 * @see CC_Error
	 */

	function popUserError()
	{
		return $this->_popErrorOfType(EM_USER_ERROR);
	}


	//-------------------------------------------------------------------
	// METHOD: getBufferSize()
	//-------------------------------------------------------------------

	/**
	 * This method gets size of the buffer for a particular type of error.
	 *
	 * @access public
	 * @return int The buffer size.
	 * @see CC_Error
	 */

	function getBufferSize($type)
	{
		switch ($type)
		{
			case EM_FIELD_ERROR:
			case EM_USER_ERROR:
			{
				return 25;
			}
			break;
			
			case EM_APPLICATION_ERROR:
			default:
			{
				return 10;
			}
		}
	}
}

?>